11주차

# Effect로 동기화하기

### 📖 주요 내용 요약

#### **1. Effect의 기본 개념**
Effect는 렌더링 자체에 의해 발생하는 부수 효과를 특정하는 것으로, 특정 이벤트가 아닌 렌더링에 의해 직접 발생합니다. Effect를 사용하면 렌더링 후 특정 코드를 실행하여 React 외부의 시스템과 컴포넌트를 동기화할 수 있습니다.

#### **2. Effect 작성 3단계**
Effect를 작성하기 위해서는 다음 세 단계를 따릅니다: 1) Effect 선언, 2) Effect 의존성 지정, 3) 필요한 경우 클린업 함수 추가.

#### **3. 의존성 관리**
React는 지정한 모든 종속성이 이전 렌더링의 그것과 정확히 동일한 값을 가진 경우에만 Effect를 다시 실행하지 않습니다. React는 Object.is 비교를 사용하여 종속성 값을 비교합니다.

#### **4. 클린업의 중요성**
React는 Effect가 다시 실행되기 전마다 클린업 함수를 호출하고, 컴포넌트가 마운트 해제(제거)될 때에도 마지막으로 호출합니다.

#### **5. 개발 모드의 특별한 동작**
React는 개발 모드에서 초기 마운트 후 모든 컴포넌트를 한 번 다시 마운트합니다. 이는 Effect가 올바르게 클린업되는지 확인하기 위한 것입니다.

### 🚫 **Effect가 필요 없는 경우들**

#### **렌더링용 데이터 변환**
렌더링을 위해 데이터를 변환하는 데는 Effect가 필요하지 않습니다. 렌더링 중에 계산할 수 있다면 Effect가 필요하지 않습니다. 비싼 계산을 캐시하려면 useEffect 대신 useMemo를 추가하세요.

#### **사용자 이벤트 처리**
사용자 이벤트를 처리하는 데는 Effect가 필요하지 않습니다. 구매 버튼 클릭 시 POST 요청을 보내는 것은 특정 상호작용에 따른 이벤트이므로 이벤트 핸들러에서 처리해야 합니다.

### 🔄 **Effect의 생명주기**

Effect는 컴포넌트와 다른 생명주기를 가집니다. 컴포넌트는 마운트, 업데이트, 언마운트할 수 있지만, Effect는 두 가지만 할 수 있습니다: 무언가를 동기화하기 시작하고, 나중에 동기화를 중지하는 것.

컴포넌트 내부의 모든 값들(props, state, 컴포넌트 본문의 변수들 포함)은 반응형입니다. 반응형 값은 재렌더링 시 변경될 수 있으므로, 반응형 값들을 Effect의 의존성으로 포함해야 합니다.

### 💡 **Effect 사용 패턴들**

#### **1. 서드파티 위젯 제어**
지도 컴포넌트의 `setZoomLevel()` 같은 메서드 호출

#### **2. 이벤트 구독**
`addEventListener`/`removeEventListener` 패턴

#### **3. 애니메이션 트리거**
클린업에서 초기값으로 리셋

#### **4. 데이터 페칭**
AbortController를 사용한 중단 처리

#### **5. 분석 로그 전송**
페이지 방문 시 분석 이벤트 전송

### 챌린지
#### 챌린지 1 of 4: 마운트시 input 필드에 포커스하기

```typescript jsx
import { useEffect, useRef } from 'react';

export default function MyInput({ value, onChange }) {
  const ref = useRef(null);

  
  useEffect(() => {
    if(ref.current){
      ref.current.focus()
    }
  }, [])

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}

```
#### 챌린지 2 of 4: 조건부로 input 필드에 포커스하기 
```typescript jsx
import { useEffect, useRef } from 'react';

export default function MyInput({ shouldFocus, value, onChange }) {
  const ref = useRef(null);

  useEffect(() => {
    if(!shouldFocus) return
    ref.current.focus();
  }, [shouldFocus]);

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}

```

#### 챌린지 3 of 4: 두 번 실행되는 interval 고치기 
```typescript jsx
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    function onTick() {
      setCount(c => c + 1);
    }

    const interval = setInterval(onTick, 1000);
    return () => {
      clearInterval(interval)
    }
  }, []);

  return <h1>{count}</h1>;
}

```
#### 챌린지 4 of 4: Effect 내부에서의 잘못된 데이터 페칭 고치기 

https://codesandbox.io/p/sandbox/react-dev-forked-tvvn37?file=%2Fsrc%2FApp.js%3A15%2C26
https://developer.mozilla.org/en-US/docs/Web/API/AbortController

# Effect가 필요하지 않은 경우

### 📖 **핵심 개념**

Effect는 React 패러다임에서 벗어날 수 있는 탈출구입니다. Effect를 사용하면 React를 "벗어나" 컴포넌트를 React가 아닌 위젯, 네트워크, 또는 브라우저 DOM과 같은 외부 시스템과 동기화할 수 있습니다.

**Effect가 필요하지 않은 두 가지 주요 경우:**
1. **렌더링용 데이터 변환**
2. **사용자 이벤트 처리**

불필요한 Effect를 제거하면 코드를 더 쉽게 따라갈 수 있고, 실행 속도가 빨라지며, 에러 발생 가능성이 줄어듭니다.

### 🚫 **Effect가 필요 없는 패턴들**

#### **1. Props/State 기반 상태 업데이트**
```javascript
// ❌ 잘못된 방법
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  const [fullName, setFullName] = useState('');
  
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
}

// ✅ 올바른 방법
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  // 렌더링 중에 계산
  const fullName = firstName + ' ' + lastName;
}
```

기존 props나 state에서 계산할 수 있는 것이 있으면, 그것을 state에 넣지 마세요. 대신, 렌더링 중에 계산하게 하세요.

#### **2. 비용이 많이 드는 계산**
```javascript
// ✅ useMemo로 캐싱
import { useMemo } from 'react';

function TodoList({ todos, filter }) {
  const visibleTodos = useMemo(() => {
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);
}
```

**성능 측정 팁:**
console.time과 console.timeEnd를 사용하여 시간을 측정할 수 있습니다. 전체적으로 기록된 시간이 상당한 양(예: 1ms 이상)으로 합산되면 해당 계산을 메모이제이션하는 것이 좋습니다.

#### **3. Prop 변경 시 State 초기화**
```javascript
// ❌ Effect 사용
function ProfilePage({ userId }) {
  const [comment, setComment] = useState('');
  
  useEffect(() => {
    setComment('');
  }, [userId]);
}

// ✅ key 사용
function ProfilePage({ userId }) {
  return <Profile userId={userId} key={userId} />;
}

function Profile({ userId }) {
  const [comment, setComment] = useState('');
  // key 변경 시 자동으로 재설정됨
}
```

userId를 key로 전달하면 React가 userId가 다른 두 개의 Profile 컴포넌트를 state를 공유해서는 안 되는 두 개의 다른 컴포넌트로 취급하도록 요청하는 것입니다.

#### **4. 렌더링 중 State 조정**
```javascript
function List({ items }) {
  const [selection, setSelection] = useState(null);
  const [prevItems, setPrevItems] = useState(items);
  
  // 렌더링 중 state 조정
  if (items !== prevItems) {
    setPrevItems(items);
    setSelection(null);
  }
}
```

### ✅ **올바른 대안들**

#### **1. 이벤트 핸들러 간 로직 공유**
```javascript
// ✅ 공유 함수 사용
function ProductPage({ product, addToCart }) {
  function buyProduct() {
    addToCart(product);
    showNotification(`Added ${product.name} to the shopping cart!`);
  }

  function handleBuyClick() {
    buyProduct();
  }

  function handleCheckoutClick() {
    buyProduct();
    navigateTo('/checkout');
  }
}
```

#### **2. POST 요청과 이벤트 구분**
```javascript
function Form() {
  // ✅ 컴포넌트 표시로 인한 analytics
  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_form' });
  }, []);

  function handleSubmit(e) {
    e.preventDefault();
    // ✅ 특정 상호작용으로 인한 API 요청
    post('/api/register', { firstName, lastName });
  }
}
```

어떤 로직을 이벤트 핸들러에 넣을지 Effect에 넣을지 선택할 때 사용자 관점에서 어떤 종류의 로직인지에 대한 답을 찾아야 합니다.

#### **3. Effect 체인 방지**
```javascript
// ❌ Effect 체인
useEffect(() => {
  if (card !== null && card.gold) {
    setGoldCardCount(c => c + 1);
  }
}, [card]);

useEffect(() => {
  if (goldCardCount > 3) {
    setRound(r => r + 1);
    setGoldCardCount(0);
  }
}, [goldCardCount]);

// ✅ 이벤트 핸들러에서 모든 state 계산
function handlePlaceCard(nextCard) {
  setCard(nextCard);
  if (nextCard.gold) {
    if (goldCardCount <= 3) {
      setGoldCardCount(goldCardCount + 1);
    } else {
      setGoldCardCount(0);
      setRound(round + 1);
      if (round === 5) {
        alert('Good game!');
      }
    }
  }
}
```

#### **4. 외부 저장소 구독**
```javascript
// ✅ useSyncExternalStore 사용
function useOnlineStatus() {
  return useSyncExternalStore(
    subscribe, // 구독 함수
    () => navigator.onLine, // 클라이언트에서 값 가져오기
    () => true // 서버에서 값 가져오기
  );
}

function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}
```

이 접근 방식은 변경 가능한 데이터를 Effect를 사용해 React state에 수동으로 동기화하는 것보다 에러가 덜 발생합니다.

#### **5. 데이터 페칭 모범 사례**
```javascript
// ✅ 정리 함수로 경쟁 조건 방지
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  
  useEffect(() => {
    let ignore = false;
    
    fetchResults(query, page).then(json => {
      if (!ignore) {
        setResults(json);
      }
    });
    
    return () => {
      ignore = true;
    };
  }, [query, page]);
}

// ✅ 커스텀 훅으로 추출
function useData(url) {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    let ignore = false;
    
    fetch(url)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setData(json);
        }
      });
    
    return () => {
      ignore = true;
    };
  }, [url]);
  
  return data;
}
```

### 🎯 **핵심 판단 기준**

컴포넌트가 사용자에게 표시되었기 때문에 실행되어야 하는 코드에만 Effect를 사용하세요.

**질문해야 할 것들:**
- 이 코드가 특정 상호작용 때문에 실행되는가? → 이벤트 핸들러
- 렌더링 중에 계산할 수 있는가? → 직접 계산 또는 useMemo
- 외부 시스템과 동기화가 필요한가? → Effect 사용

### 🔗 **관련 주요 개념들**

1. **React 렌더링 모델**: 렌더링은 React가 컴포넌트를 호출하여 화면에 무엇을 표시할지 알아내는 것입니다. 커밋 단계에서 React는 DOM을 업데이트합니다

2. **State 구조 선택**: state를 구조화할 때의 원칙은 관련 state 그룹화, 모순 방지, 중복 방지, 깊은 중첩 방지입니다

3. **State 끌어올리기**: 두 컴포넌트를 조정하려면 공통 부모로 state를 이동하세요

### 📋 **요약**

렌더링 중에 무언가를 계산할 수 있다면 Effect가 필요하지 않습니다. 비용이 많이 드는 계산을 캐시하려면 useEffect 대신 useMemo를 추가하세요. 전체 컴포넌트 트리의 state를 초기화하려면 다른 key를 전달하세요.

### 챌린지
#### 챌린지 1 of 4: Effect 없이 데이터 변환하기 
https://codesandbox.io/p/sandbox/react-dev-forked-x63hgq?file=%2Fsrc%2FApp.js%3A20%2C51

#### 챌린지 2 of 4: Effect 없이 계산 캐시하기 
```typescript jsx
import { useState, useEffect, useMemo } from 'react';
import { initialTodos, createTodo, getVisibleTodos } from './todos.js';

export default function TodoList() {
  const [todos, setTodos] = useState(initialTodos);
  const [showActive, setShowActive] = useState(false);
  const [text, setText] = useState('');

  const visibleTodos = useMemo( () => {
    return getVisibleTodos(todos, showActive)
  }, [todos, showActive])

  function handleAddClick() {
    setText('');
    setTodos([...todos, createTodo(text)]);
  }

  return (
    <>
      <label>
        <input
          type="checkbox"
          checked={showActive}
          onChange={e => setShowActive(e.target.checked)}
        />
        Show only active todos
      </label>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={handleAddClick}>
        Add
      </button>
      <ul>
        {visibleTodos.map(todo => (
          <li key={todo.id}>
            {todo.completed ? <s>{todo.text}</s> : todo.text}
          </li>
        ))}
      </ul>
    </>
  );
}

```
#### 챌린지 3 of 4: Effect 없이 state 초기화하기 
```typescript jsx
import { useState, useEffect } from 'react';

const Form = ({savedContact, onSave}) => {
  const [name, setName] = useState(savedContact.name);
  const [email, setEmail] = useState(savedContact.email);

  return (
    <section >
      <label>
        Name:{' '}
        <input
          type="text"
          value={name}
          onChange={e => setName(e.target.value)}
        />
      </label>
      <label>
        Email:{' '}
        <input
          type="email"
          value={email}
          onChange={e => setEmail(e.target.value)}
        />
      </label>
      <button onClick={() => {
        const updatedData = {
          id: savedContact.id,
          name: name,
          email: email
        };
        onSave(updatedData);
      }}>
        Save
      </button>
      <button onClick={() => {
        setName(savedContact.name);
        setEmail(savedContact.email);
      }}>
        Reset
      </button>
    </section>
  )
}

export default function EditContact({ savedContact, onSave }) {
  return (
    <Form key={savedContact.id} savedContact={savedContact} onSave={onSave} />
  );
}

```
#### 챌린지 4 of 4: Effect 없이 폼 제출하기 
```typescript jsx
import { useState, useEffect } from 'react';

export default function Form() {
  const [showForm, setShowForm] = useState(false);
  const [message, setMessage] = useState('');

  function handleSubmit(e) {
    e.preventDefault();
    setShowForm((state) => !state);    
    sendMessage(message);
  }

  if (!showForm) {
    return (
      <>
        <h1>Thanks for using our services!</h1>
        <button onClick={() => {
          setMessage('');
          setShowForm((state) => !state);
        }}>
          Open chat
        </button>
      </>
    );
  }

  return (
    <form onSubmit={handleSubmit}>
      <textarea
        placeholder="Message"
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
      <button type="submit" disabled={message === ''}>
        Send
      </button>
    </form>
  );
}

function sendMessage(message) {
  console.log('Sending message: ' + message);
}

```