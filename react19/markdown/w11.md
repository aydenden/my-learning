11주차

# Effect로 동기화하기

### 📖 주요 내용 요약

#### **1. Effect의 기본 개념**
Effect는 렌더링 자체에 의해 발생하는 부수 효과를 특정하는 것으로, 특정 이벤트가 아닌 렌더링에 의해 직접 발생합니다. Effect를 사용하면 렌더링 후 특정 코드를 실행하여 React 외부의 시스템과 컴포넌트를 동기화할 수 있습니다.

#### **2. Effect 작성 3단계**
Effect를 작성하기 위해서는 다음 세 단계를 따릅니다: 1) Effect 선언, 2) Effect 의존성 지정, 3) 필요한 경우 클린업 함수 추가.

#### **3. 의존성 관리**
React는 지정한 모든 종속성이 이전 렌더링의 그것과 정확히 동일한 값을 가진 경우에만 Effect를 다시 실행하지 않습니다. React는 Object.is 비교를 사용하여 종속성 값을 비교합니다.

#### **4. 클린업의 중요성**
React는 Effect가 다시 실행되기 전마다 클린업 함수를 호출하고, 컴포넌트가 마운트 해제(제거)될 때에도 마지막으로 호출합니다.

#### **5. 개발 모드의 특별한 동작**
React는 개발 모드에서 초기 마운트 후 모든 컴포넌트를 한 번 다시 마운트합니다. 이는 Effect가 올바르게 클린업되는지 확인하기 위한 것입니다.

### 🚫 **Effect가 필요 없는 경우들**

#### **렌더링용 데이터 변환**
렌더링을 위해 데이터를 변환하는 데는 Effect가 필요하지 않습니다. 렌더링 중에 계산할 수 있다면 Effect가 필요하지 않습니다. 비싼 계산을 캐시하려면 useEffect 대신 useMemo를 추가하세요.

#### **사용자 이벤트 처리**
사용자 이벤트를 처리하는 데는 Effect가 필요하지 않습니다. 구매 버튼 클릭 시 POST 요청을 보내는 것은 특정 상호작용에 따른 이벤트이므로 이벤트 핸들러에서 처리해야 합니다.

### 🔄 **Effect의 생명주기**

Effect는 컴포넌트와 다른 생명주기를 가집니다. 컴포넌트는 마운트, 업데이트, 언마운트할 수 있지만, Effect는 두 가지만 할 수 있습니다: 무언가를 동기화하기 시작하고, 나중에 동기화를 중지하는 것.

컴포넌트 내부의 모든 값들(props, state, 컴포넌트 본문의 변수들 포함)은 반응형입니다. 반응형 값은 재렌더링 시 변경될 수 있으므로, 반응형 값들을 Effect의 의존성으로 포함해야 합니다.

### 💡 **Effect 사용 패턴들**

#### **1. 서드파티 위젯 제어**
지도 컴포넌트의 `setZoomLevel()` 같은 메서드 호출

#### **2. 이벤트 구독**
`addEventListener`/`removeEventListener` 패턴

#### **3. 애니메이션 트리거**
클린업에서 초기값으로 리셋

#### **4. 데이터 페칭**
AbortController를 사용한 중단 처리

#### **5. 분석 로그 전송**
페이지 방문 시 분석 이벤트 전송

### 챌린지
#### 챌린지 1 of 4: 마운트시 input 필드에 포커스하기

```typescript jsx
import { useEffect, useRef } from 'react';

export default function MyInput({ value, onChange }) {
  const ref = useRef(null);

  
  useEffect(() => {
    if(ref.current){
      ref.current.focus()
    }
  }, [])

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}

```
#### 챌린지 2 of 4: 조건부로 input 필드에 포커스하기 
```typescript jsx
import { useEffect, useRef } from 'react';

export default function MyInput({ shouldFocus, value, onChange }) {
  const ref = useRef(null);

  useEffect(() => {
    if(!shouldFocus) return
    ref.current.focus();
  }, [shouldFocus]);

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}

```

#### 챌린지 3 of 4: 두 번 실행되는 interval 고치기 
```typescript jsx
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    function onTick() {
      setCount(c => c + 1);
    }

    const interval = setInterval(onTick, 1000);
    return () => {
      clearInterval(interval)
    }
  }, []);

  return <h1>{count}</h1>;
}

```
#### 챌린지 4 of 4: Effect 내부에서의 잘못된 데이터 페칭 고치기 

https://codesandbox.io/p/sandbox/react-dev-forked-tvvn37?file=%2Fsrc%2FApp.js%3A15%2C26
https://developer.mozilla.org/en-US/docs/Web/API/AbortController