# 206. Reverse Linked List

## 문제 분석

### 핵심 포인트
**연결 리스트의 포인터 방향을 완전히 뒤집는 것**이 핵심입니다.
- 원본: 1 → 2 → 3 → 4 → 5 → null
- 결과: 5 → 4 → 3 → 2 → 1 → null

### 요구사항 분석
- 단방향 연결 리스트를 역순으로 변환
- 원본 리스트의 구조를 그대로 활용
- head를 입력받아 새로운 head 반환

### 제약사항 확인
- 노드 개수: 0 ~ 5000개
- 노드 값: -5000 ~ 5000
- Follow up: 반복적/재귀적 두 방법 모두 구현

## 접근 방법

### 방법 1: 반복적(Iterative) 접근
- **시간복잡도**: O(n)
- **공간복잡도**: O(1)
- **설명**: 세 개의 포인터(prev, curr, next)를 사용하여 순차적으로 방향을 뒤집음

#### 포인터 이동 메커니즘
```
세 개의 포인터 사용:
- prev: 이전 노드 (초기값: null)
- curr: 현재 노드 (초기값: head)
- next: 다음 노드 (임시 저장용)

핵심 순서:
1. next = curr.next 저장 (연결 끊기 전에!)
2. curr.next = prev 변경 (방향 뒤집기)
3. prev = curr로 이동
4. curr = next로 이동
```

### 방법 2: 재귀적(Recursive) 접근
- **시간복잡도**: O(n)
- **공간복잡도**: O(n) - 콜 스택 사용
- **설명**: 끝까지 재귀 호출 후 돌아오면서 포인터 방향을 역전

#### 재귀 동작 원리
```
"가장 끝까지 가서 거꾸로 연결하며 돌아온다"

1. Base case: null 또는 마지막 노드 도달
2. 재귀 호출로 나머지 부분 처리
3. 돌아오면서 head.next.next = head로 방향 역전
4. head.next = null로 순환 참조 방지
```

## 최종 풀이

### 반복적 해법
```typescript
function reverseList(head: ListNode | null): ListNode | null {
    let prev: ListNode | null = null;           // O(1) space
    let curr: ListNode | null = head;           // O(1) space

    while (curr !== null) {                     // O(n) time
        const next: ListNode | null = curr.next; // O(1) space, O(1) time
        curr.next = prev;                       // O(1) time - 방향 역전
        prev = curr;                            // O(1) time - 포인터 이동
        curr = next;                            // O(1) time - 포인터 이동
    }

    return prev;                                // O(1) time - 새로운 head
}
```

### 재귀적 해법
```typescript
function reverseListRecursive(head: ListNode | null): ListNode | null {
    if (head === null || head.next === null) { // O(1) time - base case
        return head;
    }

    const newHead = reverseListRecursive(head.next); // O(n-1) time, O(n) space

    head.next.next = head;                      // O(1) time - 방향 역전
    head.next = null;                           // O(1) time - 순환 참조 방지

    return newHead;                             // O(1) time
}
```

### 최적화된 해법 (구조 분해 할당)
```typescript
function reverseListOptimized(head: ListNode | null): ListNode | null {
    if (!head || !head.next) return head;      // O(1) time - edge case

    let prev = null;                            // O(1) space
    let curr = head;                            // O(1) space

    while (curr) {                              // O(n) time
        [curr.next, prev, curr] = [prev, curr, curr.next]; // O(1) time - 동시 할당
    }

    return prev;                                // O(1) time
}
```

## 학습 포인트

### 핵심 개념
1. **포인터 조작의 안전성**: 연결을 끊기 전에 다음 노드를 반드시 저장
2. **세 포인터 패턴**: prev, curr, next의 체계적 관리
3. **재귀의 백트래킹**: 끝까지 간 후 돌아오면서 처리하는 패턴

### 유사 문제
1. **[92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)** (Medium)
   - 특정 구간만 뒤집기
2. **[25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)** (Hard)
   - k개씩 그룹으로 뒤집기
3. **[24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/)** (Medium)
   - 2개씩 페어로 뒤집기

### 실전 응용
- **Undo/Redo 기능**: 작업 이력을 역순으로 처리
- **브라우저 히스토리**: 뒤로 가기 구현
- **데이터 스트림 처리**: 최근 데이터부터 역순 처리
- **스택 구현**: LIFO 순서로 데이터 처리

### 면접 팁
1. **공간복잡도 질문**: 반복적 방법이 O(1)로 더 효율적
2. **원본 보존 질문**: 새 리스트 생성하는 방법도 설명 가능
3. **에러 케이스**: null, 단일 노드 처리 확인
4. **follow-up**: 재귀 스택 오버플로우 문제 언급