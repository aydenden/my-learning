# 20. Valid Parentheses

## Step 1: 문제 이해 및 재정의 🤔
💭 **먼저 시도해보세요:**
- **문제를 자신의 말로 설명:**
  - 괄호 문자들로만 이루어진 문자열이 주어집니다 (`()`, `{}`, `[]`)
  - 모든 괄호가 올바르게 열리고 닫히는지 확인해야 합니다
  - 올바른 괄호란: 1) 같은 타입끼리 매칭 2) 올바른 순서로 닫힘 3) 모든 닫는 괄호에 대응하는 여는 괄호 존재

- **예제 손풀이:**
  ```
  "()" → ( 저장 → ) 만나서 ( 제거 → 성공 ✓
  "()[]{}" → ()제거 → []제거 → {}제거 → 성공 ✓
  "(]" → ( 저장 → ] 만났는데 (와 매칭 안됨 → 실패 ✗
  "([)]" → ( 저장 → [ 저장 → ) 만났는데 최근 것은 [ → 실패 ✗
  "([])" → ( 저장 → [ 저장 → ] 제거 → ) 제거 → 성공 ✓
  ```

- **엣지 케이스:**
  - 홀수 길이 문자열 → 절대 유효할 수 없음
  - 닫는 괄호로 시작 → 바로 실패
  - 여는 괄호만 있음 → 실패
  - 빈 문자열 → (문제 조건상 길이 >= 1)

<details>
<summary>💡 힌트</summary>

- **입력:** 문자열 `s` (길이 1~10,000, 오직 괄호 문자만)
- **출력:** boolean (유효하면 true)
- **핵심:** "가장 최근의" 여는 괄호와 매칭되어야 함 → LIFO 구조!

</details>

✅ **체크포인트:** 이것이 LIFO(Last In First Out) 특성을 가진 문제라는 것을 파악했나요?

---

## Step 2: 패턴 인식 및 분류 🔍
💭 **먼저 시도해보세요:**
- **문제 유형:**
  - Stack 문제 (Topic Tags: String, Stack)
  - 괄호 매칭 (Bracket Matching Pattern)

- **왜 Stack인가?**
  - 여는 괄호를 만나면 "나중에 사용할 것"으로 저장
  - 닫는 괄호를 만나면 "가장 최근에 저장한 것"과 매칭
  - 이는 Stack의 push/pop 연산과 완벽히 일치

- **필요한 자료구조:**
  - Stack (배열로 구현 가능)
  - 괄호 매핑 테이블 (Map/Object)

<details>
<summary>💡 힌트</summary>

- **Stack의 특징:** LIFO (Last In, First Out)
- **괄호 매칭:** 중첩된 구조는 안쪽부터 해결되어야 함
- **유사 문제:** HTML 태그 검증, 수식 괄호 검사

</details>

✅ **체크포인트:** Stack 자료구조가 이 문제에 최적인 이유를 이해했나요?

---

## Step 3: 브루트포스 접근 💪
💭 **먼저 시도해보세요:**
- **가장 직관적인 방법:**
  - 괄호 쌍을 찾아서 계속 제거
  - 빈 문자열이 되면 성공

<details>
<summary>💡 힌트</summary>

- 문자열에서 `()`, `[]`, `{}` 패턴을 찾아 제거
- 더 이상 제거할 것이 없을 때까지 반복
- 최종적으로 빈 문자열이면 유효

</details>

```typescript
// 브루트포스 솔루션
function bruteForceSolution(s: string): boolean {
    let str = s;
    // 더 이상 괄호 쌍이 없을 때까지 반복
    while (str.includes('()') || str.includes('[]') || str.includes('{}')) {
        str = str.replace('()', ''); // TC: O(n)
        str = str.replace('[]', ''); // TC: O(n)
        str = str.replace('{}', ''); // TC: O(n)
    }
    return str.length === 0;
}
// 시간복잡도: O(n²) - 최악의 경우 n번 반복, 각 반복마다 O(n)
// 공간복잡도: O(n) - 새 문자열 생성
```

**예시:**
- `"([])"`
  - 1회차: `"([])"` → `"()"`
  - 2회차: `"()"` → `""`
  - 결과: true ✓

✅ **체크포인트:** 작동하지만 비효율적이죠? O(n²)을 O(n)으로 개선할 수 있을까요?

---

## Step 4: 병목 지점 분석 🔍
💭 **먼저 시도해보세요:**
- **브루트포스의 문제점:**
  1. 매번 문자열 전체를 탐색 (O(n))
  2. 여러 번 반복 (최대 n/2번)
  3. 문자열 교체 시마다 새로운 문자열 생성
  4. 이미 확인한 부분도 재탐색

- **비효율적인 부분:**
  - 괄호 쌍을 찾기 위해 매번 처음부터 순회
  - 한 번의 순회로 충분한데 여러 번 순회

<details>
<summary>💡 힌트</summary>

- **핵심 인사이트:** 문자를 한 번만 순회하면서 즉시 판단 가능
- **Big O 분석:**
  - 현재: O(n) × O(n) = O(n²)
  - 목표: O(n) - 한 번만 순회
- **개선 포인트:** 문자를 읽을 때마다 바로 Stack에 push/pop

</details>

✅ **체크포인트:** "한 번만 순회하면서 즉시 매칭 확인"이 가능하다는 것을 알았나요?

---

## Step 5: 최적화 전략 수립 🚀
💭 **먼저 시도해보세요:**
- **최적화 아이디어:**
  1. Stack을 사용하여 여는 괄호 저장
  2. 닫는 괄호를 만나면 Stack의 top과 즉시 매칭
  3. 한 번의 순회로 완료

- **알고리즘 설계:**
  ```
  1. Stack 초기화 (빈 배열)
  2. 문자열을 왼쪽부터 순회:
     a. 여는 괄호 (,{,[ → Stack에 push
     b. 닫는 괄호 ),},] →
        - Stack이 비어있으면 false
        - Stack.top이 매칭되지 않으면 false
        - 매칭되면 pop
  3. 순회 완료 후: Stack이 비어있으면 true, 아니면 false
  ```

<details>
<summary>💡 힌트</summary>

- **매칭 테이블:** `{')': '(', '}': '{', ']': '['}`
- **시간복잡도:** O(n) - 한 번만 순회
- **공간복잡도:** O(n) - 최악의 경우 모든 괄호가 여는 괄호
- **트레이드오프:** 시간을 크게 개선하면서 공간은 동일

</details>

✅ **체크포인트:** Stack 기반 O(n) 알고리즘을 설계했나요?

---

## Step 6: 구현 및 디버깅 🛠️
💭 **먼저 시도해보세요:**
- **구현 단계:**
  1. 홀수 길이 조기 반환 (최적화)
  2. Stack 및 매칭 Map 초기화
  3. 문자 순회 로직 구현
  4. 최종 Stack 상태 확인

- **주의사항:**
  - 빈 Stack에서 pop 시도하지 않기
  - 여는/닫는 괄호 구분 정확히
  - 최종적으로 Stack이 완전히 비어야 함

<details>
<summary>💡 힌트</summary>

- **구현 팁:**
  - `stack[stack.length - 1]`로 top 확인
  - 여는 괄호 판별: `char === '(' || char === '{' || char === '['`
  - 또는 pairs 객체에 없으면 여는 괄호
- **디버깅 포인트:**
  - `"((("` → Stack에 남음 → false
  - `")))"`→ 첫 문자에서 바로 false
  - `"([)]"` → ']'에서 매칭 실패

</details>

```typescript
/*
  전체 시간복잡도(Time Complexity): O(n)
  전체 공간복잡도(Space Complexity): O(n)
  (n: 문자열의 길이)
*/
function isValid(s: string): boolean {
    // 홀수 길이는 절대 유효할 수 없음 (조기 반환)
    if (s.length % 2 !== 0) return false; // TC: O(1), SC: O(1)

    const stack: string[] = []; // SC: O(n)

    // 닫는 괄호 → 여는 괄호 매핑
    const pairs: Record<string, string> = { // SC: O(1)
        ')': '(',
        '}': '{',
        ']': '['
    };

    for (const char of s) { // TC: O(n)
        // 여는 괄호인 경우: Stack에 추가
        if (char === '(' || char === '{' || char === '[') {
            stack.push(char); // TC: O(1)
        }
        // 닫는 괄호인 경우: 매칭 확인
        else {
            // Stack이 비어있거나 top과 매칭 안 되면 실패
            if (stack.length === 0 || stack[stack.length - 1] !== pairs[char]) {
                return false; // TC: O(1)
            }
            stack.pop(); // TC: O(1)
        }
    }

    // 모든 괄호가 올바르게 닫혔는지 확인
    return stack.length === 0; // TC: O(1)
}
```

**테스트 케이스 검증:**
```
"()" → [( → pop → [] → true ✓
"()[]{}" → [( → [] → [{ → [] → [[{ → [[ → [] → true ✓
"(]" → [( → top '(' ≠ pairs[']' = '[' → false ✓
"([)]" → [([ → top '[' ≠ pairs[')' = '(' → false ✓
"([])" → [([ → [( → [] → true ✓
"(((" → [(((] → false ✓
")))" → 첫 문자에서 stack.length === 0 → false ✓
```

✅ **체크포인트:** 모든 테스트 케이스와 엣지 케이스를 통과했나요?

---

## Step 7: 복잡도 분석 및 변형 문제 🎯
💭 **먼저 시도해보세요:**
- **최종 복잡도 계산:**
  - 시간: 문자열 한 번 순회 O(n), 각 연산 O(1) → **O(n)**
  - 공간: Stack 최대 크기 O(n), 매핑 테이블 O(1) → **O(n)**

- **제약사항 변화 고려:**
  - 괄호 종류가 10개로 늘어난다면? → Map에 추가만 하면 됨
  - 문자열 길이가 10억이라면? → O(n)이므로 여전히 효율적
  - 유효하지 않은 괄호를 제거하는 최소 횟수는? → 다른 알고리즘 필요 (DP)

<details>
<summary>💡 힌트</summary>

- **복잡도가 최적인 이유:**
  - 각 문자를 정확히 한 번만 방문: O(n)
  - 이보다 빠를 수 없음 (모든 문자 확인 필수)

- **관련 개념:**
  - Stack: 컴파일러, 함수 호출 스택
  - DFS 알고리즘도 Stack 활용

</details>

## 최종 정리
- **시간복잡도:** O(n) - 문자열을 한 번만 순회
- **공간복잡도:** O(n) - 최악의 경우 모든 괄호가 여는 괄호
- **핵심 아이디어:**
  - Stack의 LIFO 특성을 활용한 괄호 매칭
  - 여는 괄호는 push, 닫는 괄호는 pop & 매칭 확인
  - 한 번의 순회로 O(n) 시간에 해결

- **유사 문제:**
  - [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) (Medium) - 백트래킹
  - [32. Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/) (Hard) - DP/Stack
  - [301. Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/) (Hard) - BFS/DFS
  - [1249. Minimum Remove to Make Valid Parentheses](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/) (Medium)

- **실전 응용:**
  - **컴파일러 설계:** 프로그래밍 언어의 문법 검사 (Syntax Validation)
  - **HTML/XML 파서:** 태그 매칭 검증 (`<div>...</div>`)
  - **수식 평가기:** 수학 수식의 괄호 검사 및 계산
  - **텍스트 에디터:** 자동 괄호 완성 기능
  - **코드 포맷터:** 코드 구조 분석 및 정렬

- **패턴 확장:**
  - 단순 괄호 → 중첩된 태그 구조
  - 유효성 검사 → 자동 교정/완성
  - 일반 Stack → 인덱스 추적 Stack (위치 정보 포함)

✅ **최종 체크포인트:** Stack 패턴을 다른 문제에도 적용할 수 있나요?
