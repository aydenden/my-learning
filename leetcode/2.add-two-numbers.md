# 2. Add Two Numbers

## 문제 분석

### 핵심 포인트
**역순으로 저장된 두 숫자를 연결 리스트로 더하는 것**이 핵심입니다.
- 숫자가 역순 저장: 342는 [2,4,3]으로 표현
- 각 노드는 한 자리 숫자만 포함 (0-9)
- 덧셈 결과도 역순 연결 리스트로 반환

### 요구사항 분석
- 두 개의 비어있지 않은 연결 리스트
- 음이 아닌 정수를 역순으로 저장
- 각 노드는 단일 숫자만 포함
- 0을 제외하고 선행 0은 없음
- 결과를 연결 리스트로 반환

### 제약사항 확인
- 각 리스트의 노드 개수: 1 ~ 100개
- 노드 값: 0 ~ 9
- 선행 0이 없는 수 보장

## 접근 방법

### 방법 1: 반복적(Iterative) 접근
- **시간복잡도**: O(max(m, n))
- **공간복잡도**: O(max(m, n))
- **설명**: 두 리스트를 동시에 순회하며 각 자리수를 더하고 carry를 관리

#### 핵심 메커니즘
```
1. Dummy head 노드 생성 (결과 리스트 시작점)
2. 두 리스트를 동시에 순회
3. 각 자리의 합 계산 (val1 + val2 + carry)
4. 새 노드 생성 (합 % 10)
5. Carry 업데이트 (합 / 10)
6. 다음 노드로 이동
7. 마지막 carry 처리
```

#### 동작 예시
```
l1: 2→4→3 (342)
l2: 5→6→4 (465)

반복 1: 2 + 5 + 0 = 7 → 노드(7), carry = 0
반복 2: 4 + 6 + 0 = 10 → 노드(0), carry = 1
반복 3: 3 + 4 + 1 = 8 → 노드(8), carry = 0

결과: 7→0→8 (807)
```

### 방법 2: 재귀적(Recursive) 접근
- **시간복잡도**: O(max(m, n))
- **공간복잡도**: O(max(m, n)) - 콜 스택 + 결과 리스트
- **설명**: 재귀 호출로 각 자리를 처리하며 carry를 전달

#### 재귀 설계
```
Base case: 모든 리스트가 null이고 carry도 0
Recursive case: 현재 자리 계산 후 다음 자리로 재귀 호출
```

### 방법 3: 최적화된 반복 접근
- **시간복잡도**: O(max(m, n))
- **공간복잡도**: O(max(m, n))
- **특징**: Optional chaining과 구조 분해 할당으로 코드 간결화

## 최종 풀이

### 기본 반복적 해법
```typescript
/*
  전체 시간복잡도(Time Complexity): O(1) + O(1) + O(1) + O(max(m, n)) + O(1) -> O(max(m, n))
  전체 공간복잡도(Space Complexity): O(1) + O(1) + O(1) + O(max(m, n)) -> O(max(m, n))
  (m: l1의 노드 개수, n: l2의 노드 개수)
*/
function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    const result = new ListNode(0); // TC: O(1), SC: O(1)
    let current = result; // TC: O(1), SC: O(1)
    let carry = 0; // TC: O(1), SC: O(1)

    while (l1 || l2 || carry) { // TC: O(max(m, n)) - 더 긴 리스트만큼 반복
        let val1 = l1?.val || 0; // TC: O(1)
        let val2 = l2?.val || 0; // TC: O(1)

        let sum = val1 + val2 + carry; // TC: O(1)

        current.next = new ListNode(sum % 10); // TC: O(1), SC: O(1) - 새 노드

        carry = Math.floor(sum / 10); // TC: O(1)

        current = current.next; // TC: O(1)
        if (l1) l1 = l1.next; // TC: O(1)
        if (l2) l2 = l2.next; // TC: O(1)
    }

    return result.next; // TC: O(1)
}
```

### 재귀적 해법
```typescript
/*
  전체 시간복잡도(Time Complexity): O(max(m, n))
  전체 공간복잡도(Space Complexity): O(max(m, n)) + O(max(m, n)) -> O(max(m, n))
  (콜 스택: O(max(m, n)), 결과 리스트: O(max(m, n)))
*/
function addTwoNumbersRecursive(
    l1: ListNode | null,
    l2: ListNode | null,
    carry: number = 0
): ListNode | null {
    if (!l1 && !l2 && carry === 0) { // TC: O(1) - Base case
        return null;
    }

    const val1 = l1?.val || 0; // TC: O(1)
    const val2 = l2?.val || 0; // TC: O(1)
    const sum = val1 + val2 + carry; // TC: O(1)

    const node = new ListNode(sum % 10); // TC: O(1), SC: O(1)

    node.next = addTwoNumbersRecursive( // TC: O(max(m, n) - 1), SC: O(max(m, n))
        l1?.next || null,
        l2?.next || null,
        Math.floor(sum / 10)
    );

    return node; // TC: O(1)
}
```

### 최적화된 해법
```typescript
/*
  전체 시간복잡도(Time Complexity): O(max(m, n))
  전체 공간복잡도(Space Complexity): O(max(m, n))
  (m: l1의 노드 개수, n: l2의 노드 개수)
*/
function addTwoNumbersOptimized(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    const dummy = new ListNode(0); // TC: O(1), SC: O(1)
    let tail = dummy; // TC: O(1), SC: O(1)
    let carry = 0; // TC: O(1), SC: O(1)

    while (l1 || l2 || carry) { // TC: O(max(m, n))
        const sum = (l1?.val ?? 0) + (l2?.val ?? 0) + carry; // TC: O(1)

        tail.next = new ListNode(sum % 10); // TC: O(1), SC: O(1)
        tail = tail.next; // TC: O(1)
        carry = Math.floor(sum / 10); // TC: O(1)

        l1 = l1?.next ?? null; // TC: O(1)
        l2 = l2?.next ?? null; // TC: O(1)
    }

    return dummy.next; // TC: O(1)
}
```

## 학습 포인트

### 핵심 개념
1. **Dummy Head 패턴**: 첫 노드 처리 로직 단순화
2. **Carry 처리**: 자리 올림을 다음 자리로 전달하는 메커니즘
3. **동시 순회**: 길이가 다른 두 리스트를 안전하게 처리
4. **역순 저장의 장점**: 덧셈 특성상 낮은 자리부터 처리하므로 유리

### 유사 문제
1. **[67. Add Binary](https://leetcode.com/problems/add-binary/)** (Easy)
   - 이진수 문자열 덧셈
2. **[415. Add Strings](https://leetcode.com/problems/add-strings/)** (Easy)
   - 큰 수를 문자열로 표현한 덧셈
3. **[445. Add Two Numbers II](https://leetcode.com/problems/add-two-numbers-ii/)** (Medium)
   - 정순으로 저장된 리스트 덧셈 (더 어려움)
4. **[43. Multiply Strings](https://leetcode.com/problems/multiply-strings/)** (Medium)
   - 문자열 곱셈으로 확장

### 실전 응용
- **대용량 숫자 처리**: JavaScript Number 타입 한계(2^53) 극복
- **암호화 연산**: RSA 등에서 큰 수 연산 필요
- **금융 시스템**: 정밀한 소수점 계산
- **과학 계산**: 매우 큰 수나 높은 정밀도 요구

### 면접 팁
1. **엣지 케이스 확인**: 빈 리스트, 길이 차이, 마지막 carry
2. **공간복잡도 질문**: 새 리스트 생성 vs 기존 리스트 재사용
3. **확장 가능성**: 곱셈, 뺄셈, 음수 처리 방법
4. **최적화**: 비트 연산, 메모리 절약 기법