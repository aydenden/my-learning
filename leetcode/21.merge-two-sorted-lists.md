# 21. Merge Two Sorted Lists 학습 노트

## 📋 문제 개요

두 개의 정렬된 연결 리스트를 하나의 정렬된 연결 리스트로 병합하는 문제

**입력 예시:**
```
list1 = [1,2,4]
list2 = [1,3,4]
```

**출력:**
```
[1,1,2,3,4,4]
```

## 🧠 핵심 개념

### 연결 리스트 (Linked List)
```
[1] -> [2] -> [4] -> null
 ↑
head
```
- 각 노드는 값(val)과 다음 노드 포인터(next)를 가짐
- 동적 크기, 삽입/삭제가 효율적

### 병합 정렬의 Merge 단계
- 두 정렬된 배열/리스트를 하나로 병합
- 매번 두 개의 원소만 비교하면 됨

## 🤔 사고 과정

### 1단계: 문제 관찰
- 두 리스트가 이미 정렬되어 있음 ← 핵심!
- 매번 더 작은 값을 선택하면 됨

### 2단계: While 조건 설계
```typescript
while (list1 !== null && list2 !== null)
```
**이유:**
- 비교하려면 둘 다 필요
- 하나라도 끝나면 비교 불필요
- 남은 부분은 그대로 연결

### 3단계: Dummy Node 패턴
- 첫 노드 처리를 단순화
- 두 개의 포인터 사용:
  - `dummy`: 시작점 고정 (절대 이동 안함)
  - `current`: 작업용 포인터 (이동함)

## ⚠️ 구현 과정에서의 실수와 학습

### 실수 1: 포인터 참조 vs 이동의 혼동
```typescript
// ❌ 잘못된 방식
let resultNode = new ListNode();
resultNode = resultNode.next;  // resultNode가 가리키는 대상 변경
return resultNode;  // 시작점을 잃어버림

// ✅ 올바른 방식
let resultNode = new ListNode();  // 고정
let current = resultNode;         // 작업용
current = current.next;           // current만 이동
return resultNode.next;           // 시작점 유지
```

### 핵심 깨달음
- **변수가 가리키는 대상을 바꾸는 것**과 **객체 내용을 변경하는 것**은 다름
- 같은 객체를 참조하더라도 변수 이동은 별개

### 실수 2: 남은 리스트 처리 누락
```typescript
// while 루프 후 반드시 필요
current.next = list1 !== null ? list1 : list2;
```

## 📊 복잡도 분석

### 시간 복잡도: O(n + m)
- n = list1의 노드 개수
- m = list2의 노드 개수
- 각 노드를 정확히 한 번씩만 방문

### 공간 복잡도: O(1)
- 새로운 노드 생성 없이 기존 노드 재사용
- 포인터 몇 개만 사용

### 라인별 복잡도
```typescript
let resultNode = new ListNode();           // TC: O(1), SC: O(1)
let current = resultNode;                  // TC: O(1), SC: O(1)
while (list1 !== null && list2 !== null)  // TC: O(n+m), SC: O(1)
  if (list1.val <= list2.val)             // TC: O(1)
    current.next = list1;                  // TC: O(1)
    list1 = list1.next;                    // TC: O(1)
  current = current.next;                  // TC: O(1)
current.next = list1 !== null ? list1 : list2;  // TC: O(1), SC: O(1)
```

## 🎯 최적화 분석

### 현재 코드가 최적인 이유
1. **시간**: O(n+m) - 이론적 최적
2. **공간**: O(1) - 최소 공간
3. **안정성**: 스택 오버플로우 없음
4. **가독성**: 명확하고 이해하기 쉬움

### 다른 접근법 비교

#### 재귀 방식
```typescript
function mergeTwoLists(list1, list2) {
  if (!list1) return list2;
  if (!list2) return list1;

  if (list1.val <= list2.val) {
    list1.next = mergeTwoLists(list1.next, list2);
    return list1;
  } else {
    list2.next = mergeTwoLists(list1, list2.next);
    return list2;
  }
}
```
- **장점**: 코드가 간결
- **단점**: O(n+m) 스택 공간 사용, 긴 리스트에서 스택 오버플로우 위험

## 💡 핵심 학습 포인트

1. **Dummy Node 패턴**: 연결 리스트 문제의 강력한 패턴
2. **두 포인터 기법**: 하나는 고정, 하나는 이동
3. **포인터 참조 이해**: 변수 이동 vs 객체 내용 변경
4. **복잡도 분석**: 각 노드를 한 번씩만 방문하므로 O(n+m)
5. **엣지 케이스**: 빈 리스트, 남은 리스트 처리

## 🔗 관련 문제

- Merge k Sorted Lists (Hard)
- Merge Sorted Array (Easy)
- Sort List (Medium)

이 문제는 연결 리스트와 병합 알고리즘의 기본을 이해하는 중요한 문제입니다!