# 21. Merge Two Sorted Lists ν•™μµ λ…ΈνΈ

## π“‹ λ¬Έμ  κ°μ”

λ‘ κ°μ μ •λ ¬λ μ—°κ²° λ¦¬μ¤νΈλ¥Ό ν•λ‚μ μ •λ ¬λ μ—°κ²° λ¦¬μ¤νΈλ΅ λ³‘ν•©ν•λ” λ¬Έμ 

**μ…λ ¥ μμ‹:**
```
list1 = [1,2,4]
list2 = [1,3,4]
```

**μ¶λ ¥:**
```
[1,1,2,3,4,4]
```

## π§  ν•µμ‹¬ κ°λ…

### μ—°κ²° λ¦¬μ¤νΈ (Linked List)
```
[1] -> [2] -> [4] -> null
 β†‘
head
```
- κ° λ…Έλ“λ” κ°’(val)κ³Ό λ‹¤μ λ…Έλ“ ν¬μΈν„°(next)λ¥Ό κ°€μ§
- λ™μ  ν¬κΈ°, μ‚½μ…/μ‚­μ κ°€ ν¨μ¨μ 

### λ³‘ν•© μ •λ ¬μ Merge λ‹¨κ³„
- λ‘ μ •λ ¬λ λ°°μ—΄/λ¦¬μ¤νΈλ¥Ό ν•λ‚λ΅ λ³‘ν•©
- λ§¤λ² λ‘ κ°μ μ›μ†λ§ λΉ„κµν•λ©΄ λ¨

## π¤” μ‚¬κ³  κ³Όμ •

### 1λ‹¨κ³„: λ¬Έμ  κ΄€μ°°
- λ‘ λ¦¬μ¤νΈκ°€ μ΄λ―Έ μ •λ ¬λμ–΄ μμ β† ν•µμ‹¬!
- λ§¤λ² λ” μ‘μ€ κ°’μ„ μ„ νƒν•λ©΄ λ¨

### 2λ‹¨κ³„: While μ΅°κ±΄ μ„¤κ³„
```typescript
while (list1 !== null && list2 !== null)
```
**μ΄μ :**
- λΉ„κµν•λ ¤λ©΄ λ‘ λ‹¤ ν•„μ”
- ν•λ‚λΌλ„ λλ‚λ©΄ λΉ„κµ λ¶ν•„μ”
- λ‚¨μ€ λ¶€λ¶„μ€ κ·Έλ€λ΅ μ—°κ²°

### 3λ‹¨κ³„: Dummy Node ν¨ν„΄
- μ²« λ…Έλ“ μ²λ¦¬λ¥Ό λ‹¨μν™”
- λ‘ κ°μ ν¬μΈν„° μ‚¬μ©:
  - `dummy`: μ‹μ‘μ  κ³ μ • (μ λ€ μ΄λ™ μ•ν•¨)
  - `current`: μ‘μ—…μ© ν¬μΈν„° (μ΄λ™ν•¨)

## β οΈ κµ¬ν„ κ³Όμ •μ—μ„μ μ‹¤μμ™€ ν•™μµ

### μ‹¤μ 1: ν¬μΈν„° μ°Έμ΅° vs μ΄λ™μ νΌλ™
```typescript
// β μλ»λ λ°©μ‹
let resultNode = new ListNode();
resultNode = resultNode.next;  // resultNodeκ°€ κ°€λ¦¬ν‚¤λ” λ€μƒ λ³€κ²½
return resultNode;  // μ‹μ‘μ μ„ μƒμ–΄λ²„λ¦Ό

// β… μ¬λ°”λ¥Έ λ°©μ‹
let resultNode = new ListNode();  // κ³ μ •
let current = resultNode;         // μ‘μ—…μ©
current = current.next;           // currentλ§ μ΄λ™
return resultNode.next;           // μ‹μ‘μ  μ μ§€
```

### ν•µμ‹¬ κΉ¨λ‹¬μ
- **λ³€μκ°€ κ°€λ¦¬ν‚¤λ” λ€μƒμ„ λ°”κΎΈλ” κ²ƒ**κ³Ό **κ°μ²΄ λ‚΄μ©μ„ λ³€κ²½ν•λ” κ²ƒ**μ€ λ‹¤λ¦„
- κ°™μ€ κ°μ²΄λ¥Ό μ°Έμ΅°ν•λ”λΌλ„ λ³€μ μ΄λ™μ€ λ³„κ°

### μ‹¤μ 2: λ‚¨μ€ λ¦¬μ¤νΈ μ²λ¦¬ λ„λ½
```typescript
// while λ£¨ν”„ ν›„ λ°λ“μ‹ ν•„μ”
current.next = list1 !== null ? list1 : list2;
```

## π“ λ³µμ΅λ„ λ¶„μ„

### μ‹κ°„ λ³µμ΅λ„: O(n + m)
- n = list1μ λ…Έλ“ κ°μ
- m = list2μ λ…Έλ“ κ°μ
- κ° λ…Έλ“λ¥Ό μ •ν™•ν ν• λ²μ”©λ§ λ°©λ¬Έ

### κ³µκ°„ λ³µμ΅λ„: O(1)
- μƒλ΅μ΄ λ…Έλ“ μƒμ„± μ—†μ΄ κΈ°μ΅΄ λ…Έλ“ μ¬μ‚¬μ©
- ν¬μΈν„° λ‡ κ°λ§ μ‚¬μ©

### λΌμΈλ³„ λ³µμ΅λ„
```typescript
let resultNode = new ListNode();           // TC: O(1), SC: O(1)
let current = resultNode;                  // TC: O(1), SC: O(1)
while (list1 !== null && list2 !== null)  // TC: O(n+m), SC: O(1)
  if (list1.val <= list2.val)             // TC: O(1)
    current.next = list1;                  // TC: O(1)
    list1 = list1.next;                    // TC: O(1)
  current = current.next;                  // TC: O(1)
current.next = list1 !== null ? list1 : list2;  // TC: O(1), SC: O(1)
```

## π― μµμ ν™” λ¶„μ„

### ν„μ¬ μ½”λ“κ°€ μµμ μΈ μ΄μ 
1. **μ‹κ°„**: O(n+m) - μ΄λ΅ μ  μµμ 
2. **κ³µκ°„**: O(1) - μµμ† κ³µκ°„
3. **μ•μ •μ„±**: μ¤νƒ μ¤λ²„ν”λ΅μ° μ—†μ
4. **κ°€λ…μ„±**: λ…ν™•ν•κ³  μ΄ν•΄ν•κΈ° μ‰¬μ›€

### λ‹¤λ¥Έ μ ‘κ·Όλ²• λΉ„κµ

#### μ¬κ·€ λ°©μ‹
```typescript
function mergeTwoLists(list1, list2) {
  if (!list1) return list2;
  if (!list2) return list1;

  if (list1.val <= list2.val) {
    list1.next = mergeTwoLists(list1.next, list2);
    return list1;
  } else {
    list2.next = mergeTwoLists(list1, list2.next);
    return list2;
  }
}
```
- **μ¥μ **: μ½”λ“κ°€ κ°„κ²°
- **λ‹¨μ **: O(n+m) μ¤νƒ κ³µκ°„ μ‚¬μ©, κΈ΄ λ¦¬μ¤νΈμ—μ„ μ¤νƒ μ¤λ²„ν”λ΅μ° μ„ν—

## π’΅ ν•µμ‹¬ ν•™μµ ν¬μΈνΈ

1. **Dummy Node ν¨ν„΄**: μ—°κ²° λ¦¬μ¤νΈ λ¬Έμ μ κ°•λ ¥ν• ν¨ν„΄
2. **λ‘ ν¬μΈν„° κΈ°λ²•**: ν•λ‚λ” κ³ μ •, ν•λ‚λ” μ΄λ™
3. **ν¬μΈν„° μ°Έμ΅° μ΄ν•΄**: λ³€μ μ΄λ™ vs κ°μ²΄ λ‚΄μ© λ³€κ²½
4. **λ³µμ΅λ„ λ¶„μ„**: κ° λ…Έλ“λ¥Ό ν• λ²μ”©λ§ λ°©λ¬Έν•λ―€λ΅ O(n+m)
5. **μ—£μ§€ μΌ€μ΄μ¤**: λΉ λ¦¬μ¤νΈ, λ‚¨μ€ λ¦¬μ¤νΈ μ²λ¦¬

## π”— κ΄€λ ¨ λ¬Έμ 

- Merge k Sorted Lists (Hard)
- Merge Sorted Array (Easy)
- Sort List (Medium)

μ΄ λ¬Έμ λ” μ—°κ²° λ¦¬μ¤νΈμ™€ λ³‘ν•© μ•κ³ λ¦¬μ¦μ κΈ°λ³Έμ„ μ΄ν•΄ν•λ” μ¤‘μ”ν• λ¬Έμ μ…λ‹λ‹¤!