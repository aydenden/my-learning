# 92. Reverse Linked List II

## Step 1: 문제 이해 및 재정의 🤔
💭 **먼저 시도해보세요:**
- 연결 리스트에서 특정 구간(left번째부터 right번째)만 역순으로 뒤집는 문제입니다
- 예제: [1,2,3,4,5]에서 2~4번째를 뒤집으면 [1,4,3,2,5]
- 나머지 부분은 그대로 유지해야 합니다

**손풀이 과정:**
```
원본: 1 → 2 → 3 → 4 → 5, left=2, right=4

1. left 이전(1)은 그대로
2. 2→3→4를 역순으로: 4→3→2
3. right 이후(5)는 그대로
4. 연결: 1 → 4 → 3 → 2 → 5
```

**엣지 케이스:**
- left = 1인 경우 (head부터 역순)
- left = right인 경우 (뒤집을 필요 없음)
- 리스트가 1개 노드만 있는 경우

<details>
<summary>💡 힌트</summary>

**입력/출력:**
- 입력: head (연결 리스트), left (시작 위치, 1-indexed), right (끝 위치)
- 출력: 부분 역순된 연결 리스트의 head

**제약사항:**
- 1 ≤ n ≤ 500 (노드 개수)
- 1 ≤ left ≤ right ≤ n
- Follow-up: One pass로 해결 가능

</details>

✅ **체크포인트:** left~right 구간만 뒤집고 나머지는 유지한다는 것을 이해했나요?

---

## Step 2: 패턴 인식 및 분류 🔍
💭 **먼저 시도해보세요:**
- **문제 유형:** 연결 리스트 (Linked List) + 포인터 조작
- **유사 문제:** 206. Reverse Linked List (전체 리스트 역순)
- **필요 자료구조:** 포인터 3~4개 (이전, 현재, 다음 노드 추적)

**핵심 패턴:**
- 연결 리스트 부분 역순은 전체 역순의 응용입니다
- 특정 구간만 처리하려면 "경계 노드"들을 기억해야 합니다

<details>
<summary>💡 힌트</summary>

**알고리즘 유형:**
- Linked List Manipulation
- Two/Multiple Pointers 기법

**핵심 키워드:**
- "reverse between positions" → 부분 역순
- "one pass" → O(n) 시간에 한 번 순회로 해결

**기억할 노드들:**
1. left 이전 노드 (연결 복원용)
2. left 노드 (역순 후 꼬리가 됨)
3. right 노드 (역순 후 머리가 됨)
4. right 다음 노드 (연결 복원용)

</details>

✅ **체크포인트:** 어떤 노드들을 추적해야 하는지 파악했나요?

---

## Step 3: 브루트포스 접근 💪
💭 **먼저 시도해보세요:**
- 가장 직관적인 방법: 리스트를 배열로 변환 → 부분 역순 → 다시 리스트로
- 또는: left~right 구간을 잘라내서 별도로 역순 → 다시 붙이기

<details>
<summary>💡 힌트</summary>

**브루트포스 접근법:**
1. 연결 리스트를 배열로 변환
2. 배열의 left-1 ~ right-1 인덱스 구간을 reverse
3. 배열을 다시 연결 리스트로 변환

**장점:** 구현이 쉽고 이해하기 쉬움
**단점:**
- O(n) 추가 공간 필요
- 변환 과정이 비효율적

</details>

```typescript
// 브루트포스 솔루션 (배열 변환 방식)
/*
  시간복잡도: O(n) - 리스트→배열 O(n) + 역순 O(right-left) + 배열→리스트 O(n)
  공간복잡도: O(n) - 배열 저장
*/
function reverseBetweenBruteForce(
  head: ListNode | null,
  left: number,
  right: number
): ListNode | null {
  if (!head) return null;

  // 1. 리스트를 배열로 변환 - TC: O(n), SC: O(n)
  const arr: number[] = [];
  let curr = head;
  while (curr) {
    arr.push(curr.val);
    curr = curr.next;
  }

  // 2. left~right 구간 역순 - TC: O(right-left)
  let l = left - 1, r = right - 1;
  while (l < r) {
    [arr[l], arr[r]] = [arr[r], arr[l]];
    l++;
    r--;
  }

  // 3. 배열을 다시 리스트로 변환 - TC: O(n), SC: O(n)
  const dummy = new ListNode(0);
  curr = dummy;
  for (const val of arr) {
    curr.next = new ListNode(val);
    curr = curr.next;
  }

  return dummy.next;
}
```

✅ **체크포인트:** 작동하지만 비효율적인 O(n) 공간 해법을 이해했나요?

---

## Step 4: 병목 지점 분석 🔍
💭 **먼저 시도해보세요:**
- **병목 1:** 배열 변환에 O(n) 추가 공간 사용
- **병목 2:** 실제로는 left~right 구간만 처리하면 되는데 전체를 변환
- **반복 작업:** 리스트→배열→리스트 변환이 불필요

**Big O 분석:**
- 시간: O(n) - 세 번의 순회 (변환 2번 + 역순 1번)
- 공간: O(n) - 배열 저장

<details>
<summary>💡 힌트</summary>

**개선 포인트:**
- 배열 변환 없이 포인터만으로 in-place 역순 가능
- left~right 구간만 순회하면 됨
- 추가 공간을 O(1)로 줄일 수 있음

**핵심 질문:**
- 연결 리스트 전체 역순은 어떻게 하나요? → prev, curr, next 포인터 3개로 가능
- 부분 역순도 같은 원리를 적용할 수 있지 않을까요?

</details>

✅ **체크포인트:** O(n) 공간을 O(1)로 줄일 수 있다는 것을 알았나요?

---

## Step 5: 최적화 전략 수립 🚀
💭 **먼저 시도해보세요:**
- **핵심 아이디어:** Linked List 206번 전체 역순 알고리즘을 부분적으로 적용
- **최적화 기법:** In-place reversal (포인터 조작만으로)
- **트레이드오프:** 시간은 동일 O(n), 공간은 O(n) → O(1)로 개선

**전략:**
1. **Dummy 노드 사용:** left=1인 엣지 케이스를 일반화
2. **4개 포인터 관리:**
   - `beforeLeft`: left 이전 노드
   - `leftNode`: left 노드 (역순 후 꼬리)
   - `curr`: 현재 처리 중인 노드
   - `rightNext`: right 다음 노드 (역순 후 연결)

3. **One Pass 알고리즘:**
   ```
   Step 1: left-1 위치까지 이동 (beforeLeft 찾기)
   Step 2: left~right 구간 역순 (표준 reversal 기법)
   Step 3: 앞뒤 연결 복원
   ```

<details>
<summary>💡 힌트</summary>

**최적화 기법들:**
- **Dummy Head Pattern:** head 변경 가능성이 있을 때 유용
- **Standard Reversal:** prev, curr, next 포인터로 화살표 방향 바꾸기
  ```
  원본: A → B → C
  역순: A ← B ← C

  while (curr) {
    next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  ```

**구간 역순 핵심:**
```
1 → 2 → 3 → 4 → 5, left=2, right=4

beforeLeft = 1
leftNode = 2

역순 과정:
1 → 2 ← 3 ← 4   5
    ↓           ↑
  leftNode   rightNext

최종 연결:
1 → 4 → 3 → 2 → 5
```

</details>

✅ **체크포인트:** In-place 포인터 조작으로 O(1) 공간에 해결할 전략을 세웠나요?

---

## Step 6: 구현 및 디버깅 🛠️
💭 **먼저 시도해보세요:**
- Dummy 노드부터 시작
- left-1까지 이동하는 반복문
- left~right 역순 반복문
- 연결 복원 로직

<details>
<summary>💡 힌트</summary>

**구현 순서:**
1. Dummy 노드 생성 (left=1 대응)
2. beforeLeft까지 이동 (left-1번 이동)
3. 역순할 구간의 시작(leftNode) 기억
4. left~right 구간 표준 reversal
5. beforeLeft.next = 역순된 head
6. leftNode.next = rightNext

**주의사항:**
- left=1일 때 beforeLeft는 dummy
- right 이후 노드가 null일 수 있음
- 포인터 null 체크 필수

**디버깅 팁:**
- 예제: [1,2,3,4,5], left=2, right=4로 손으로 그리며 추적
- 각 단계 후 연결 상태 확인

</details>

```typescript
/*
  전체 시간복잡도(Time Complexity): O(n)
  전체 공간복잡도(Space Complexity): O(1)
  (n: 연결 리스트의 노드 개수)

  동작 원리:
  1. Dummy 노드로 left=1 엣지 케이스 처리
  2. left-1 위치까지 이동하여 beforeLeft 찾기 - TC: O(left)
  3. left~right 구간을 표준 reversal로 역순 - TC: O(right-left)
  4. 역순된 구간을 앞뒤로 연결 복원 - TC: O(1)
*/
function reverseBetween(
  head: ListNode | null,
  left: number,
  right: number
): ListNode | null {
  if (!head || left === right) return head;

  // Dummy 노드로 left=1 엣지 케이스 처리
  const dummy = new ListNode(0);
  dummy.next = head;

  // Step 1: left-1 위치까지 이동 - TC: O(left)
  let beforeLeft = dummy;
  for (let i = 0; i < left - 1; i++) {
    beforeLeft = beforeLeft.next!;
  }

  // Step 2: left~right 구간 역순 - TC: O(right-left)
  let prev: ListNode | null = null;
  let curr: ListNode | null = beforeLeft.next; // left 노드
  const leftNode = curr; // 역순 후 꼬리가 될 노드

  // 표준 reversal 기법
  for (let i = 0; i <= right - left; i++) {
    const next = curr!.next;
    curr!.next = prev;
    prev = curr;
    curr = next;
  }
  // 반복 후: prev = right 노드 (역순된 head), curr = right+1 노드

  // Step 3: 연결 복원
  beforeLeft.next = prev; // left 이전과 역순된 head 연결
  leftNode!.next = curr; // 역순된 꼬리와 right 이후 연결

  return dummy.next;
}
```

**테스트 케이스 검증:**
```
Example 1: [1,2,3,4,5], left=2, right=4
- beforeLeft = 1
- leftNode = 2
- 역순: 2→3→4 → 4→3→2
- 최종: 1→4→3→2→5 ✓

Example 2: [5], left=1, right=1
- left === right 조건으로 조기 리턴 ✓

Edge Case: [1,2], left=1, right=2
- dummy 덕분에 정상 작동
- 결과: 2→1 ✓
```

✅ **체크포인트:** 모든 테스트를 통과하고 엣지 케이스도 처리했나요?

---

## Step 7: 복잡도 분석 및 변형 문제 🎯
💭 **먼저 시도해보세요:**
- **최종 복잡도 계산:**
  - 시간: O(left) + O(right-left) + O(1) = O(n)
  - 공간: O(1) (포인터만 사용)

- **변형 문제 고민:**
  - 여러 구간을 동시에 역순? → 각 구간마다 이 알고리즘 적용
  - K개씩 묶어서 역순? → 25. Reverse Nodes in k-Group
  - 홀수 위치만 역순? → 조건부 reversal

<details>
<summary>💡 힌트</summary>

**복잡도 분석:**
- **시간복잡도:** O(n)
  - Worst case: left=1, right=n일 때 전체 순회
  - Best case: left=right일 때 O(1) (조기 리턴)

- **공간복잡도:** O(1)
  - 고정된 포인터 변수만 사용 (dummy, beforeLeft, prev, curr, leftNode)
  - 재귀 없음, 추가 자료구조 없음

**관련 문제들:**
- LeetCode 206: Reverse Linked List (전체 역순) - 더 쉬움
- LeetCode 25: Reverse Nodes in k-Group - 더 어려움
- LeetCode 24: Swap Nodes in Pairs - 유사 패턴

**실무 활용:**
- Undo/Redo 시스템에서 부분 명령 취소
- 데이터 스트림 처리에서 특정 구간 재정렬
- 메모리 효율적인 순서 변경 작업

</details>

## 최종 정리
- **시간복잡도:** O(n) - 리스트를 한 번만 순회 (left까지 이동 + 구간 역순)
- **공간복잡도:** O(1) - 포인터 변수만 사용, 추가 자료구조 없음
- **핵심 아이디어:**
  1. Dummy 노드 패턴으로 head 변경 엣지 케이스 일반화
  2. 표준 reversal 기법(prev, curr, next)을 특정 구간에만 적용
  3. 4개 포인터로 경계 관리 (beforeLeft, leftNode, prev, curr)
  4. One-pass로 효율적 해결

- **유사 문제:**
  - 206. Reverse Linked List (기본 개념)
  - 25. Reverse Nodes in k-Group (심화)
  - 24. Swap Nodes in Pairs (패턴 유사)

- **실전 응용:**
  - 메모리 효율적인 순서 재정렬
  - Linked List 기반 자료구조 조작
  - In-place 알고리즘 설계 패턴

**학습 포인트:**
- Dummy 노드는 head 변경이 필요한 문제에서 코드를 단순화합니다
- 복잡한 포인터 조작은 그림을 그리며 단계별로 추적하세요
- 경계 조건(left=1, right=n)을 항상 테스트하세요

✅ **체크포인트:** Linked List 부분 역순 패턴을 완전히 이해하고 다른 문제에 응용할 수 있나요?
