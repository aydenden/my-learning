# LeetCode 학습 가이드라인

## 문제 해결 프로세스

사용자가 문제를 문의하면 다음 단계를 따라 진행합니다:

### 1. 문제 검색 및 조회
- LeetCode MCP를 활용하여 문제 검색
- 파일명(예: 121.best-time-to-buy-and-sell-stock.ts)과 내용에서 문제 번호와 문제 이름 매칭
- 정확한 문제 정보 확인

### 2. 7단계 점진적 학습 접근법

#### Step 1: 문제 이해 및 재정의 🤔
💭 **먼저 시도해보세요:**
- 문제를 자신의 말로 다시 설명해보세요
- 주어진 예제를 손으로 직접 풀어보세요
- 어떤 엣지 케이스가 있을지 생각해보세요

💡 **힌트:** 문제를 완전히 이해했다면 다음 질문에 답할 수 있어야 합니다
- 입력과 출력이 정확히 무엇인가요?
- 어떤 제약 조건들이 있나요?

✅ **체크포인트:** 문제의 핵심 요구사항을 명확히 파악했나요?

#### Step 2: 패턴 인식 및 분류 🔍
💭 **먼저 시도해보세요:**
- 이 문제가 어떤 유형에 속하는지 추측해보세요 (배열, 트리, 그래프, DP 등)
- 이전에 풀어본 유사한 문제가 있는지 떠올려보세요
- 어떤 자료구조가 필요할 것 같은지 예상해보세요

💡 **힌트:** 문제의 키워드나 제약조건이 알고리즘 유형을 암시합니다

✅ **체크포인트:** 문제 유형과 필요한 개념을 식별했나요?

#### Step 3: 브루트포스 접근 💪
💭 **먼저 시도해보세요:**
- 효율성은 무시하고 가장 직관적인 방법을 생각해보세요
- 모든 가능성을 다 확인하는 방법은 무엇일까요?
- 간단한 예제로 이 방법이 작동하는지 확인해보세요

💡 **힌트:** 완벽하지 않아도 됩니다. 우선 작동하는 해법부터 만드세요

✅ **체크포인트:** 비효율적이어도 정확한 해법을 찾았나요?

#### Step 4: 병목 지점 분석 🔍
💭 **먼저 시도해보세요:**
- 브루트포스에서 가장 시간이 오래 걸리는 부분은 어디인가요?
- 같은 계산을 반복하는 부분이 있나요?
- 불필요한 작업을 하는 부분이 있나요?

💡 **힌트:** Big O 분석을 해보고, 어떤 연산이 지배적인지 찾아보세요

✅ **체크포인트:** 개선해야 할 핵심 병목을 식별했나요?

#### Step 5: 최적화 전략 수립 🚀
💭 **먼저 시도해보세요:**
- 병목을 해결할 수 있는 방법들을 브레인스토밍해보세요
- 메모이제이션, 정렬, 해시맵, 투포인터 등 사용 가능한 기법들을 고려해보세요
- 시간-공간 복잡도 트레이드오프를 생각해보세요

💡 **힌트:** 여러 최적화 방법이 있을 수 있습니다. 가장 적합한 것을 선택하세요

✅ **체크포인트:** 구체적인 최적화 전략을 선택했나요?

#### Step 6: 구현 및 디버깅 🛠️
💭 **먼저 시도해보세요:**
- Helper 함수부터 구현해보세요
- 각 단계를 작은 단위로 나누어 테스트해보세요
- 예상되는 실수 지점들을 미리 체크해보세요

💡 **힌트:** 한 번에 완벽하게 구현하려 하지 말고, 단계별로 확인하며 진행하세요

✅ **체크포인트:** 모든 테스트 케이스를 통과하나요?

#### Step 7: 복잡도 분석 및 변형 문제 🎯
💭 **먼저 시도해보세요:**
- 최종 해법의 시간/공간 복잡도를 계산해보세요
- 제약사항이 바뀐다면 어떻게 접근할지 생각해보세요
- 이 문제에서 배운 패턴이 어떤 다른 문제에 적용될지 고민해보세요

💡 **힌트:** 복잡도뿐만 아니라 실무 활용도도 생각해보세요

✅ **체크포인트:** 완전한 이해와 응용 능력을 갖췄나요?

## 문서 생성 규칙

### 파일 명명 규칙
- 각 문제의 TypeScript 파일(예: 121.best-time-to-buy-and-sell-stock.ts)과 동일한 이름의 마크다운 파일을 생성
- 파일명 형식: `[문제번호].[문제이름].md`

### 문서 구조
```markdown
# [문제번호]. [문제제목]

## Step 1: 문제 이해 및 재정의 🤔
💭 **먼저 시도해보세요:**
- [문제를 자신의 말로 설명해보세요]
- [예제 손풀이 과정]
- [엣지 케이스 예상]

<details>
<summary>💡 힌트</summary>

- 입력/출력 형태 확인
- 제약사항 파악

</details>

✅ **체크포인트:** 문제 요구사항을 명확히 파악했나요?

---

## Step 2: 패턴 인식 및 분류 🔍
💭 **먼저 시도해보세요:**
- [문제 유형 분류]
- [유사 문제 경험]
- [필요 자료구조 예상]

<details>
<summary>💡 힌트</summary>

- [알고리즘 유형 힌트]
- [핵심 키워드 분석]

</details>

✅ **체크포인트:** 문제 패턴을 파악했나요?

---

## Step 3: 브루트포스 접근 💪
💭 **먼저 시도해보세요:**
- [직관적 해법 시도]

<details>
<summary>💡 힌트</summary>

- [브루트포스 접근법 가이드]

</details>

```typescript
// 브루트포스 솔루션
function bruteForceSolution(): returnType {
  // 구현
}
```

✅ **체크포인트:** 작동하는 기본 해법을 찾았나요?

---

## Step 4: 병목 지점 분석 🔍
💭 **먼저 시도해보세요:**
- [병목 지점 식별]
- [비효율적 부분 분석]

<details>
<summary>💡 힌트</summary>

- [복잡도 분석 가이드]

</details>

✅ **체크포인트:** 개선점을 찾았나요?

---

## Step 5: 최적화 전략 수립 🚀
💭 **먼저 시도해보세요:**
- [최적화 아이디어]

<details>
<summary>💡 힌트</summary>

- [최적화 기법들]
- [트레이드오프 고려사항]

</details>

✅ **체크포인트:** 최적화 전략을 선택했나요?

---

## Step 6: 구현 및 디버깅 🛠️
💭 **먼저 시도해보세요:**
- [단계별 구현]

<details>
<summary>💡 힌트</summary>

- [구현 시 주의사항]

</details>

```typescript
/*
  전체 시간복잡도(Time Complexity): O(n) + O(n/2) + ... -> O(n)
  전체 공간복잡도(Space Complexity): O(n) + O(n/2) + ... -> O(n)
  (n: 리스트/배열의 크기)
*/
function optimizedSolution(): returnType {
  const operation = someAction(); // TC: O(?), SC: O(?)
  return result; // TC: O(?), SC: O(?)
}
```

✅ **체크포인트:** 모든 테스트를 통과했나요?

---

## Step 7: 복잡도 분석 및 변형 문제 🎯
💭 **먼저 시도해보세요:**
- [복잡도 계산]
- [변형 문제 고민]

<details>
<summary>💡 힌트</summary>

- [복잡도 분석 방법]
- [관련 문제들]

</details>

## 최종 정리
- **시간복잡도:** O(?)
- **공간복잡도:** O(?)
- **핵심 아이디어:** [핵심 개념 정리]
- **유사 문제:** [관련 문제 목록]
- **실전 응용:** [실무 활용 예시]

✅ **체크포인트:** 완전한 이해에 도달했나요?
```

## 코드 작성 규칙

### 복잡도 표기 규칙
1. **함수 위 주석**: 전체 시간/공간 복잡도를 함수 바로 위에 주석으로 표기
   ```typescript
   /*
     전체 시간복잡도(Time Complexity): O(n) + O(n/2) + O(n/2) -> O(2n) -> O(n)
     전체 공간복잡도(Space Complexity): O(n) + O(1) -> O(n)
     (n: 데이터 구조의 크기 설명)
   */
   function functionName() { ... }
   ```

2. **라인별 주석**: 각 주요 연산 라인 옆에 해당 라인의 개별 TC/SC 표기, O(1)은 제외
   ```typescript
   const array = list.slice(0, half); // TC: O(n/2), SC: O(n/2)
   const result = array.reverse(); // TC: O(n/2)
   return array.every((val, i) => val === other[i]); // TC: O(n/2)
   ```

3. **복잡도 계산 과정**: 함수 위 주석에서 각 연산의 복잡도를 더해서 최종 Big O 도출 과정 표시

### TypeScript 파일 구조
- 헬퍼 함수들이 있다면 메인 함수 위에 배치
- 각 함수마다 위 복잡도 표기 규칙 적용
- 최종 solution 함수는 파일 하단에 배치

## 워크플로우
1. 사용자 문제 문의 → LeetCode MCP로 문제 검색
2. 파일명 매칭으로 해당 문제 파일 확인
3. **7단계 점진적 학습 접근법으로 단계별 가이드:**
   - 각 단계마다 사용자가 먼저 시도하도록 유도
   - 막히는 경우에만 힌트 제공
   - 체크포인트로 이해도 확인
   - 다음 단계 진행 전 충분한 고민 시간 확보
4. xxx.md 파일 생성 (기존 파일 있으면 업데이트)

### 학습 진행 원칙
- **사용자 우선 시도:** 각 단계에서 답을 바로 주지 말고 사용자가 먼저 생각할 기회 제공
- **점진적 힌트:** 막힐 때만 단서 제공, 완전한 답은 피하기
- **능동적 참여:** 수동적 설명보다 질문과 체크포인트로 능동적 사고 유도
- **단계별 검증:** 각 단계 완료 후 이해도 확인 후 다음 진행