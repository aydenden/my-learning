# 121. Best Time to Buy and Sell Stock

- 처음에는 배열을 순회하면서 min과 max를 다시 계산해서 넣어주고 마지막에 그 값의 차이를 리턴하는 식으로 접근
- 정렬이 잘 되어서 들어오면 성공하지만 그게 아닐 경우 실패함
- 중요한 포인트는 시간 순서였고 배열 순회면서 이전의 가장 작은 값과 지금의 비교가 중요
- 시간 복잡도는 한번 배열을 순회하기에 `O(n)`

```typescript
function maxProfit(prices: number[]): number {
    let result = 0;
    let min: number | null = null;

    for(const price of prices) {
        if(min !== null) {
            const calcMax = price - min;
            if(calcMax > result) {
                result = calcMax
            }
        }

        if(min === null || min > price) {
            min = price
        }
    }
    return result
};
```


## AI 피드백

### 🔑 가장 중요한 포인트
**"시간 순서"가 핵심!**
- 주식은 먼저 사야 하고 나중에 팔아야 함
- 단순히 전체 배열에서 최소값과 최대값을 찾는 것이 아님
- 각 시점에서 "지금까지의 상황"을 동적으로 추적해야 함

## 풀이 방법별 분석

### 1. `maxProfit1` - ❌ 실패한 접근법
```typescript
// 단순 최소, 최대 값을 찾기 때문에 실패
function maxProfit1(prices: number[]): number {
    let result = 0;
    let max = 0;
    let min = Number.MAX_VALUE;
    // ... 실패 로직
}
```

**실패 이유:**
- 전체 배열에서 단순히 min, max를 찾음
- 시간 순서를 무시 (max가 min보다 앞에 올 수 있음)
- 예: [7,1,5,3,6,4] → min=1, max=6이지만 실제로는 불가능한 거래

### 2. `maxProfit` (maxProfit2) - ✅ 올바른 접근법
```typescript
function maxProfit(prices: number[]): number {
    let result = 0;
    let min: number | null = null;

    for(const price of prices) {
        if(min !== null) {
            const calcMax = price - min;
            if(calcMax > result) {
                result = calcMax
            }
        }

        if(min === null || min > price) {
            min = price
        }
    }
    return result
};
```

**장점:**
- ✅ 시간 순서 올바르게 고려
- ✅ O(n) 시간복잡도, O(1) 공간복잡도

**개선점:**
- null 체크가 매번 실행되어 불필요한 연산
- 변수명이 직관적이지 않음

### 3. `maxProfit3` - 🏆 최적화된 접근법
```typescript
function maxProfit3(prices: number[]): number {
    let maxProfit = 0;
    let minPrice = prices[0];
    
    for (let i = 1; i < prices.length; i++) {
        // 현재 가격에서 팔았을 때의 이익 계산
        const profit = prices[i] - minPrice;
        maxProfit = Math.max(maxProfit, profit);
        
        // 최저가 업데이트
        minPrice = Math.min(minPrice, prices[i]);
    }
    
    return maxProfit;
}
```

**개선사항:**
- ✅ null 체크 제거로 성능 향상
- ✅ 첫 번째 원소로 minPrice 초기화
- ✅ Math.max/Math.min 사용으로 가독성 향상
- ✅ 의미있는 변수명 사용

## 알고리즘 사고 과정

### Dynamic Programming 접근법
1. **상태 정의**: 각 날짜에서의 "지금까지 최저가"와 "최대 이익"
2. **점화식**: 
   - `profit[i] = max(profit[i-1], prices[i] - minPrice[i-1])`
   - `minPrice[i] = min(minPrice[i-1], prices[i])`
3. **최적화**: 이전 상태만 필요하므로 O(1) 공간으로 축약 가능

### 핵심 통찰
- **한 번의 순회로 해결 가능**: 각 지점에서 "지금 팔면?" 계산
- **탐욕적 선택**: 각 시점에서 최선의 선택이 전체 최적해로 이어짐
- **시간순 제약**: 과거의 정보만 사용해서 현재 결정

## 복잡도 분석

| 방법 | 시간복잡도 | 공간복잡도 | 상태 |
|------|------------|------------|------|
| maxProfit1 | O(n) | O(1) | ❌ 잘못된 로직 |
| maxProfit | O(n) | O(1) | ✅ 올바름 |
| maxProfit3 | O(n) | O(1) | 🏆 최적화됨 |

## 학습 포인트

### 1. 문제 이해의 중요성
- "Best Time"은 시간 순서가 중요함을 의미
- 제약 조건을 놓치면 완전히 다른 문제가 됨

### 2. 최적화 과정
1. **브루트 포스** → O(n²) 모든 쌍 확인
2. **올바른 접근** → O(n) 한번 순회로 해결  
3. **코드 최적화** → 불필요한 조건문 제거

### 3. Dynamic Programming의 핵심
- **최적 부분 구조**: 각 부분의 최적해가 전체 최적해에 기여
- **중복 부분 문제**: 이전 계산 결과 재활용
- **메모이제이션**: 상태 공간 최적화로 O(1) 달성

## 결론
단순해 보이는 문제도 **시간 제약**을 고려하면 Dynamic Programming 사고가 필요하다. 
핵심은 "각 시점에서 지금까지의 최적 상태를 유지하며 다음으로 진행"하는 것이다.