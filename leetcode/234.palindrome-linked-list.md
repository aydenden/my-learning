# 234. Palindrome Linked List

## Step 1: 문제 이해 및 재정의 🤔
💭 **먼저 시도해보세요:**
- Singly linked list가 주어졌을 때, 이 리스트가 palindrome인지 확인하는 문제입니다
- 예제를 손으로 풀어보세요:
  - [1,2,2,1] → 앞에서 읽나 뒤에서 읽나 같음 → true
  - [1,2] → 앞에서 읽으면 1,2 뒤에서 읽으면 2,1 → false
- 엣지 케이스: 노드가 1개인 경우, 빈 리스트인 경우는?

<details>
<summary>💡 힌트</summary>

- 입력: ListNode의 head (singly linked list)
- 출력: boolean (palindrome 여부)
- 제약사항:
  - 노드 개수: 1 ~ 10^5
  - 노드 값: 0 ~ 9
  - Follow-up: O(n) 시간, O(1) 공간으로 해결 가능한가?

</details>

✅ **체크포인트:** Palindrome의 정의와 linked list의 특성을 파악했나요?

---

## Step 2: 패턴 인식 및 분류 🔍
💭 **먼저 시도해보세요:**
- 이 문제의 핵심은 무엇일까요? (배열, 문자열, 연결리스트, 투포인터 등)
- Palindrome 검사는 어떤 방식으로 할 수 있을까요?
- Singly linked list의 한계는 무엇일까요?

<details>
<summary>💡 힌트</summary>

- **문제 유형**: Linked List + Two Pointers
- **핵심 아이디어**: Palindrome = 앞뒤가 대칭
- **Linked List 특성**: 뒤에서부터 접근하기 어려움
- **관련 기법**: Array 변환, Stack 활용, Two Pointers + Reverse

</details>

✅ **체크포인트:** Linked list의 제약사항과 palindrome 검사 방법을 파악했나요?

---

## Step 3: 브루트포스 접근 💪
💭 **먼저 시도해보세요:**
- 가장 직관적인 방법은 무엇일까요?
- Linked list를 다른 자료구조로 변환한다면?

<details>
<summary>💡 힌트</summary>

- **접근법 1**: Linked List → Array 변환 후 palindrome 검사
- **접근법 2**: Stack 사용 (절반은 stack에 저장, 나머지 절반과 비교)

</details>

```typescript
// 브루트포스 솔루션 - Array 변환
function isPalindromeBruteForce(head: ListNode | null): boolean {
  const values: number[] = [];
  let current = head;

  // Linked list를 배열로 변환
  while (current !== null) {
    values.push(current.val);
    current = current.next;
  }

  // 배열에서 palindrome 검사
  let left = 0, right = values.length - 1;
  while (left < right) {
    if (values[left] !== values[right]) return false;
    left++;
    right--;
  }

  return true;
}
```

✅ **체크포인트:** 작동하는 기본 해법을 찾았나요?

---

## Step 4: 병목 지점 분석 🔍
💭 **먼저 시도해보세요:**
- 위 브루트포스 해법의 시간/공간 복잡도는?
- 가장 비효율적인 부분은 어디일까요?
- Follow-up의 O(1) 공간 조건을 만족하나요?

<details>
<summary>💡 힌트</summary>

- **시간복잡도**: O(n) - 모든 노드 순회 + palindrome 검사
- **공간복잡도**: O(n) - 배열 저장
- **병목**: 추가 공간 사용 (배열 or 스택)
- **개선 포인트**: 공간 복잡도를 O(1)로 줄일 수 있을까?

</details>

✅ **체크포인트:** 공간 복잡도가 주요 개선 포인트임을 파악했나요?

---

## Step 5: 최적화 전략 수립 🚀
💭 **먼저 시도해보세요:**
- O(1) 공간으로 해결하려면 어떤 아이디어가 필요할까요?
- Linked list 자체를 조작할 수 있다면?
- Two pointers 기법을 어떻게 활용할까요?

<details>
<summary>💡 힌트</summary>

- **핵심 아이디어**: Fast-Slow pointer로 중간 지점 찾기
- **최적화 전략**:
  1. 중간 지점까지 가면서 동시에 뒷부분 뒤집기
  2. 또는 중간 지점 찾은 후 뒷부분만 뒤집기
  3. 앞부분과 뒤집힌 뒷부분 비교
- **트레이드오프**: 원본 리스트 구조 변경 vs 공간 절약

</details>

✅ **체크포인트:** Two pointers + Reverse 전략을 선택했나요?

---

## Step 6: 구현 및 디버깅 🛠️
💭 **먼저 시도해보세요:**
- Fast-slow pointer로 중간점을 찾아보세요
- 뒷부분을 뒤집는 함수를 구현해보세요
- 앞부분과 뒤집힌 뒷부분을 비교해보세요

<details>
<summary>💡 힌트</summary>

- **구현 순서**:
  1. reverseList helper 함수
  2. findMiddle 로직 (fast-slow pointer)
  3. 비교 로직
- **주의사항**:
  - 홀수/짝수 길이 처리
  - 중간 노드 처리
  - 원본 복구 (필요시)

</details>

```typescript
/*
  전체 시간복잡도(Time Complexity): O(n)
  전체 공간복잡도(Space Complexity): O(1)
  (n: linked list의 노드 개수)
*/

// Helper: 연결리스트 뒤집기
function reverseList(head: ListNode | null): ListNode | null {
  let prev: ListNode | null = null;
  let current = head;

  while (current !== null) { // TC: O(n/2)
    const next = current.next;
    current.next = prev; // TC: O(1)
    prev = current;
    current = next;
  }

  return prev;
}

function isPalindromeOptimized(head: ListNode | null): boolean {
  if (!head || !head.next) return true;

  // 1. Fast-slow pointer로 중간 지점 찾기
  let slow = head, fast = head;
  while (fast.next && fast.next.next) { // TC: O(n/2)
    slow = slow.next!;
    fast = fast.next.next;
  }

  // 2. 뒷부분 뒤집기
  const secondHalf = reverseList(slow.next); // TC: O(n/2), SC: O(1)

  // 3. 앞부분과 뒤집힌 뒷부분 비교
  let firstHalf = head;
  let secondHalfCopy = secondHalf;
  let isPalindrome = true;

  while (secondHalfCopy !== null) { // TC: O(n/2)
    if (firstHalf!.val !== secondHalfCopy.val) {
      isPalindrome = false;
      break;
    }
    firstHalf = firstHalf!.next;
    secondHalfCopy = secondHalfCopy.next;
  }

  // 4. 원본 복구 (선택사항)
  slow.next = reverseList(secondHalf); // TC: O(n/2)

  return isPalindrome;
}
```

✅ **체크포인트:** 모든 테스트 케이스를 통과하고 O(1) 공간을 달성했나요?

---

## Step 7: 복잡도 분석 및 변형 문제 🎯
💭 **먼저 시도해보세요:**
- 최종 해법의 정확한 시간/공간 복잡도를 계산해보세요
- 만약 doubly linked list였다면 어떻게 다를까요?
- 다른 palindrome 문제들과 비교해보세요

<details>
<summary>💡 힌트</summary>

- **시간복잡도 분석**: O(n/2) + O(n/2) + O(n/2) + O(n/2) = O(n)
- **공간복잡도 분석**: O(1) - 추가 배열/스택 없이 포인터만 사용
- **관련 문제**:
  - Valid Palindrome (문자열)
  - Palindrome Number (숫자)
  - Reverse Linked List (기본기)

</details>

## 최종 정리
- **시간복잡도:** O(n)
- **공간복잡도:** O(1)
- **핵심 아이디어:** Fast-slow pointer + Linked list reversal
- **유사 문제:**
  - [9. Palindrome Number](https://leetcode.com/problems/palindrome-number/)
  - [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)
  - [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)
- **실전 응용:**
  - 메모리 제약이 있는 환경에서의 데이터 검증
  - In-place 알고리즘 설계 패턴
  - Two pointers 기법 활용

✅ **체크포인트:** 완전한 이해에 도달하고 다른 문제에도 적용할 수 있나요?