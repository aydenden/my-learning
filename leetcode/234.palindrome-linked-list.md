# 234. 팰린드롬 연결 리스트 - 학습 노트

## 문제 개요
**LeetCode 234번 - Easy**
- 단방향 연결 리스트의 head가 주어졌을 때, 팰린드롬이면 true, 아니면 false 반환
- **예시**: [1,2,2,1] → true, [1,2] → false
- **제약조건**: 1 ≤ 길이 ≤ 10^5, 0 ≤ Node.val ≤ 9

## 자료구조 기초

### 단방향 연결 리스트 (Singly Linked List)
```typescript
class ListNode {
    val: number
    next: ListNode | null
}
```

**시각적 표현:**
```
[1] -> [2] -> [3] -> [4] -> null
 ^                           ^
head                        tail
```

**핵심 특징:**
- 한 방향으로만 순회 가능
- 이전 노드에 직접 접근 불가
- 동적 크기, 비연속 메모리
- 맨 앞 삽입/삭제: O(1)
- 인덱스 접근: O(n)

### 팰린드롬 개념
- 앞에서 읽어도, 뒤에서 읽어도 같은 순서
- 예시: [1,2,1], [1,2,3,2,1], [7]

## 풀이 접근법

### 접근법 1: 배열 변환 (구현됨)
```typescript
function isPalindrome(head: ListNode | null): boolean {
  const nodeToArray = toArray(head);
  const half = Math.floor(nodeToArray.length / 2);

  const firstHalf = nodeToArray.slice(0, half);
  const secondStart = nodeToArray.length % 2 === 0 ? half : half + 1;
  const secondHalf = nodeToArray.slice(secondStart).reverse();

  return firstHalf.every((val, i) => val === secondHalf[i]);
}
```
- **시간 복잡도**: O(n)
- **공간 복잡도**: O(n)
- **장점**: 이해하고 구현하기 쉬움
- **단점**: 추가 메모리 사용

### 접근법 2: 투 포인터 (대안)
```typescript
function isPalindrome(head: ListNode | null): boolean {
  const arr = toArray(head);
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    if (arr[left] !== arr[right]) return false;
    left++;
    right--;
  }
  return true;
}
```
- **시간 복잡도**: O(n)
- **공간 복잡도**: O(n)
- **장점**: 더 직관적인 로직

### 접근법 3: O(1) 공간 솔루션 (고급)
```typescript
function isPalindrome(head: ListNode | null): boolean {
  // 1. 느린/빠른 포인터로 중간점 찾기
  let slow = head;
  let fast = head;

  while (fast && fast.next) {
    slow = slow!.next;
    fast = fast.next.next;
  }

  // 2. 뒤 절반 뒤집기
  let prev = null;
  while (slow) {
    const next = slow.next;
    slow.next = prev;
    prev = slow;
    slow = next;
  }

  // 3. 두 절반 비교
  let left = head;
  let right = prev;

  while (right) {
    if (left!.val !== right.val) return false;
    left = left!.next;
    right = right.next;
  }

  return true;
}
```
- **시간 복잡도**: O(n)
- **공간 복잡도**: O(1) ⭐
- **장점**: 최적의 공간 사용
- **단점**: 원본 리스트 수정, 더 복잡함

## 구현 과정

### 초기 버그: 재귀 스택 오버플로우
**문제 코드:**
```typescript
function toArray(node: ListNode | null): number[] {
  if (!node) return [];
  if (!node.next) return [node.val];
  return [node.val, ...toArray(node.next)];  // ❌ Stack overflow
}
```

**이슈**: JavaScript 재귀 한계 (~10,000 호출)
**테스트 케이스**: 수천 개 원소를 가진 배열

**해결책: 반복문 접근:**
```typescript
function toArray(node: ListNode | null): number[] {
  const result: number[] = [];
  let current = node;

  while (current !== null) {
    result.push(current.val);
    current = current.next;
  }

  return result;  // ✅ No stack limit
}
```

### Big-O 분석 심화

**순차적 연산:**
```
O(n) + O(n/2) + O(n/2) + O(n/2) = O(n)
```

**핵심 원리**: 가장 큰 항이 지배
- 상수는 무시됨: O(3n) = O(n)
- 중첩 루프와 달리 누적 곱셈 아님

**중첩 vs 순차:**
```typescript
// 순차: O(n) + O(n) = O(n)
for (let i = 0; i < n; i++) { /* work */ }
for (let j = 0; j < n; j++) { /* work */ }

// 중첩: O(n) × O(n) = O(n²)
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) { /* work */ }
}
```

## 핵심 학습 내용

### 1. 재귀 vs 반복문 트레이드오프
| 측면 | 재귀 | 반복문 |
|------|------|-------|
| 가독성 | 높음 | 보통 |
| 스택 안전성 | 제한적 | 무제한 |
| 메모리 사용 | O(깊이) | O(1) |
| 최적 용도 | 트리/그래프 | 큰 선형 데이터 |

### 2. 각 접근법을 선택할 때
- **재귀**: 트리 순회, 분할 정복
- **반복문**: 긴 시퀀스, 프로덕션 코드
- **JavaScript 한계**: ~10,000 재귀 호출

### 3. 문제 해결 과정
1. **이해하기**: 팰린드롬 + 연결 리스트 제약조건이 무엇인가?
2. **관찰하기**: 앞/뒤를 비교해야 하는데 뒤로 갈 수 없음
3. **계획하기**: 배열로 변환 후 표준 기법 사용
4. **구현하기**: 작성, 디버깅, 최적화
5. **디버깅**: 스택 오버플로우 → 반복문 솔루션

## 고급 기법들

### 투 포인터 (빠른/느린)
```typescript
function findMiddle(head: ListNode | null): ListNode | null {
  let slow = head;
  let fast = head;

  while (fast && fast.next) {
    slow = slow!.next;        // 1칸씩
    fast = fast.next.next;    // 2칸씩
  }

  return slow;  // 중간 노드
}
```

### 연결 리스트 뒤집기
```typescript
function reverseList(head: ListNode | null): ListNode | null {
  let prev = null;
  let current = head;

  while (current) {
    const next = current.next;  // 다음 노드 저장
    current.next = prev;        // 포인터 방향 전환
    prev = current;             // prev 이동
    current = next;             // current 이동
  }

  return prev;  // 새로운 head
}
```

## 처리된 엣지 케이스들
- 빈 리스트: `null` → `true`
- 노드 1개: `[1]` → `true`
- 노드 2개: `[1,2]` → `false`, `[1,1]` → `true`
- 홀수 길이: `[1,2,1]` → 중간값 올바르게 무시
- 짝수 길이: `[1,2,2,1]` → 완벽한 분할
- 큰 입력: 수천 개 노드 ✅

## 성능 분석
- **현재 솔루션**: O(n) 시간, O(n) 공간
- **최적 솔루션**: O(n) 시간, O(1) 공간
- **실용적 선택**: 현재 버전이 더 읽기 쉽고 유지보수하기 좋음

## 다음 단계 - 추천 문제들

### 연결 리스트 기초
- **206. Reverse Linked List** - 리스트 뒤집기 마스터
- **876. Middle of the Linked List** - 투 포인터 연습
- **141. Linked List Cycle** - 순환 감지

### 고급 팰린드롬
- **9. Palindrome Number** - 추가 공간 없이
- **125. Valid Palindrome** - 문자열 처리
- **680. Valid Palindrome II** - 한 번의 삭제 허용

### 투 포인터 마스터
- **167. Two Sum II** - 정렬된 배열
- **15. 3Sum** - 다중 포인터
- **11. Container With Most Water** - 최적화

## 마무리 생각
이 문제는 초급자에서 고급자로의 사고 발전을 아름답게 보여줍니다:
1. **초급자**: 익숙한 구조(배열)로 변환
2. **중급자**: 엣지 케이스와 성능 최적화
3. **고급자**: 영리한 기법으로 공간 복잡도 최소화

배열 접근법은 면접과 프로덕션 코드에서 완전히 유효합니다. 최적화는 정확성 다음에 와야 합니다! 🎯